I"&$<blockquote>
  <p class="note">此题以修改，详见<a href="http://pluckytyx.top/2019/08/%E6%89%AD%E8%9B%8B%E4%BF%AE%E6%94%B9%E7%89%88">扭蛋修改版</a></p>
</blockquote>

<h6 id="题目描述回忆版">题目描述（回忆版）</h6>

<p>22和33分别有一台扭蛋机，她们的扭蛋机可以进行如下操作：</p>

<ul>
  <li>22将x个扭蛋塞进去，会扭出2*x+1个扭蛋</li>
  <li>33将x个扭蛋塞进去，会扭出2*x+2个扭蛋</li>
</ul>

<p>开始时，22和33手中没有扭蛋。然后电视君想知道如何利用最少的扭蛋次数，使得最后22和33手中的扭蛋个数和为N，22和33的扭蛋可以给对方使用。</p>

<p>数据规模我不记得了。</p>

<p>输入一个N，输出使用最小的次数可得到恰好N个扭蛋的扭蛋顺序序列(‘2’代表22扭,‘3’代表33扭)</p>

<h5 id="样例输入">样例输入</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10 
</code></pre></div></div>

<h5 id="样例输出">样例输出</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>233(22扭0个，变为1个，33扭1个，变为4个，33扭4个变为10个)
</code></pre></div></div>

<h5 id="分析">分析</h5>

<p>原题目中的一句话是“自己的扭蛋可以给对方使用”，我开始认为是假定现在22和33的扭蛋之和为n那么下一次放入扭蛋机的扭蛋可以是任意小于等于n的正整数。但是题目的意思应该是每次只能放入全部扭蛋，否则应该没有唯一解（举个例子想想就明白了）。</p>

<p>所以我们的问题就变成了决定每一次让谁扭，让22扭会增加<code class="language-plaintext highlighter-rouge">n+1</code>,让33扭会增加<code class="language-plaintext highlighter-rouge">n+2</code>,所以为了尽可能少的扭动扭蛋机，我们选择优先考虑让33扭，在33扭之后无法达到目的后再让22扭。</p>

<p>也就是将33扭作为优先，进行一个dfs：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">n</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">roll3</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">roll2</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>输入参数i代表当前的扭蛋数量，<code class="language-plaintext highlighter-rouge">roll3()</code>意思为让33扭，<code class="language-plaintext highlighter-rouge">roll2()</code>意为让22扭。这个dfs的意义也就是之前分析过的，<code class="language-plaintext highlighter-rouge">优先考虑让33扭，在33扭之后无法达到目的后再让22扭</code>。</p>

<p>另外因为要输出扭蛋顺序序列，所以最终代码在dfs中增加了记录扭蛋顺序的数组。</p>

<h5 id="示例代码">示例代码</h5>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mi">1005</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">b</span><span class="p">;</span><span class="c1">//扭蛋总个数</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span><span class="c1">//求解量</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span><span class="c1">//记录扭蛋顺序</span>
<span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">roll2</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">roll3</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">n</span><span class="p">)</span><span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">roll3</span><span class="p">(</span><span class="n">i</span><span class="p">))){</span>
        <span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>
        <span class="n">p</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">roll2</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
        <span class="n">p</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>要注意，因为dfs是递归到正确的叶子节点后才开始返回，所以扭蛋顺序序列更新实际上是从最后一个人扭蛋开始记录的，故最后要逆序输出a[]。</p>

<p>这题当时没写着实因为基础不牢，忘记DFS返回的基本想法了，总结写DFS返回的基本方法：</p>

<ul>
  <li>第一步，达到要求返回1</li>
  <li>第二步，已经无法达到要求返回0</li>
  <li>第三步，按优先顺序列举不使递归结束的情况，做相应处理，返回1。</li>
</ul>
:ET