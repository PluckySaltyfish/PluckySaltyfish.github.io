---
layout: post
title: "扭蛋（修改版）"
date: 2019-08-16 13:42:31
description: 对于之前写过的一个算法题的修改
tags: 
 - Algorithm
 - DFS
---



##### 前情提要

突然翻到去年校招写的题，实在是愚蠢至极，这题就是个倒着解方程的题，故修改。

<br>

###### 题目描述（回忆版） 

[原题链接](http://pluckytyx.top/2018/09/%E6%89%AD%E8%9B%8B-bilibili2019%E6%A0%A1%E6%8B%9B)

22和33分别有一台扭蛋机，她们的扭蛋机可以进行如下操作：

- 22将x个扭蛋塞进去，会扭出2*x+1个扭蛋
- 33将x个扭蛋塞进去，会扭出2*x+2个扭蛋

开始时，22和33手中没有扭蛋。然后电视君想知道如何利用最少的扭蛋次数，使得最后22和33手中的扭蛋个数和为N，22和33的扭蛋可以给对方使用。

数据规模我不记得了。

输入一个N，输出使用最小的次数可得到恰好N个扭蛋的扭蛋顺序序列('2'代表22扭,‘3’代表33扭)

<br>

##### 样例输入

```
10 
```

##### 样例输出

```
233(22扭0个，变为1个，33扭1个，变为4个，33扭4个变为10个)
```

<br>

##### 分析

观察题面很明显，如果输入是偶数，则最后扭的人一定是33，反之一定是22。假设输入为N，则可得倒数第一次放入扭蛋机的扭蛋数为（N-1）/2，或者（N-2）/2。以此往前推，做一个dfs就可解出来。

<br>

##### 示例代码

```cpp
class Solution {
public:
    string res = "";
    void niudan(int n){
        if(n % 2 == 0){
            res = "3" + res;
            if (n == 2)
                return;
            niudan((n - 2)/2);
        }
        else{
            res = "2" + res;
            if (n == 1)
                return;
            niudan((n - 1)/2);
        }
    } 
};
```

偷懒直接在LeetCode格式模板里写的。