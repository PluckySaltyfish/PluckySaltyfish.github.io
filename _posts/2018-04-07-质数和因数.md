---
layout: post
title: "质数和因数"
date: 2018-04-07 07:18:53
description: 质数和因数相关的算法
tags: 
 - Algorithm
 - Math
 - 考研机试

---

### 质数和因数

求质数是很基础的一个数学问题，首先得明确质数的概念：除了1和它本身没有其它因数的整数（从2开始）。

最简单的质数算法：

```cpp
int prime (int n){
    for(int i = 2; i<n ;i++){
        if(n%i==0)return 0;
    }
    return 1;
}
```

简化的质数算法运用了一个很重要的数学知识：

一个整数n（1，2除外），除了1和它本身之外，它的其它因数成对出现，（例如120 = 5\*24，5和24都是120的因数），所以关心一个整数是否有除了1和它本身的因数，只需要关心每对数中的较小一个是否可以被n整除，即并不用从2遍历到它本身，只要从2遍历到sqrt\(n\)（极端情况是 n = sqrt\(n\)\*sqrt\(n\),其中sqrt\(n\)为整数，为n的一个因数）。

故简化后的质数算法可改为：

```cpp
int prime (int n){
    for(int i = 2; i<=sqrt(n) ;i++){
        if(n%i==0)return 0;
    }
    return 1;
}
```

这个简化还可以用到更多场合，看一道例题：

#### 题目描述

```
求正整数N(N>1)的质因数的个数。 相同的质因数需要重复计算。如120=2*2*2*3*5，共有5个质因数。
```

#### 输入描述

```
可能有多组测试数据，每组测试数据的输入是一个正整数N，(1<N<10^9)。
```

#### 输出描述

```
对于每组数据，输出N的质因数的个数。
```

#### 样例输入

```
120
```

#### 样例输出

```
5
```

#### 分析

题目说是找质因数，你可能会想着把质数先求一遍，然后每个除一下。别被题目骗了，事实上从小到大遍历除数的话，是不用区分除数是否是质数的。因为一个合数总能被分解成几个比它小的质数相乘，所以从小到大遍历的话，就早已经把这几个比它小的质数遍历了，不存在一个合数是因数的情况。

其次需要注意的就是寻找因数的范围。之前我们提到，因数总是成对出现，并以`sqrt(n)`为界。所以我们任然可以选择只找小的那个因数，没找到一个就对n做整除，并且更新范围边界`sqrt(n)`的值。

这样循环完成的结果就是最后剩下一个大于的因数`sqrt(n)`，故最后count要再加1。

#### 示例代码

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <vector>
using namespace std;

int main(){
    int number;
    while(cin >> number){
        int count = 0;
        for(int i = 2;i <= sqrt(number);i++){
            while(number%i==0){
                number /= i;
                count++;
            }
            if(number==1)break;
        }
        count++;
        cout << count;
        
    }
}
```



